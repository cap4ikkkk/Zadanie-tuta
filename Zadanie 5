Степанов Никита 
Иф-01
Практика 5

1. Управляем таблицами.sql
CREATE TABLE student
(
	student_id serial,
	first_name varchar,
	last_name varchar,
	birthday date,
	phone varchar
);

CREATE TABLE cathedra
(
	cathedra_id serial,
	cathedra_name varchar,
	dean varchar
);

ALTER TABLE student
ADD COLUMN middle_name varchar;

ALTER TABLE student
ADD COLUMN rating float;

ALTER TABLE student
ADD COLUMN enrolled date;

ALTER TABLE student
DROP COLUMN middle_name;

ALTER TABLE cathedra
RENAME TO chair;

ALTER TABLE chair
RENAME cathedra_id TO chair_id;

ALTER TABLE chair
RENAME cathedra_name TO chair_name;

ALTER TABLE student
ALTER COLUMN first_name SET DATA TYPE varchar(64);

ALTER TABLE student
ALTER COLUMN last_name SET DATA TYPE varchar(64);

ALTER TABLE student
ALTER COLUMN phone SET DATA TYPE varchar(30);

CREATE TABLE faculty
(
	faculty_id serial,
	faculty_name varchar
);

INSERT INTO faculty
VALUES
('faculty1'),
('faculty2'),
('faculty3');

SELECT * FROM faculty;

TRUNCATE TABLE faculty RESTART IDENTITY;

DROP TABLE faculty;

2. Первичный ключ в SQL (PRIMARY KEY)
DROP TABLE chair;
CREATE TABLE chair
(
	cathedra_id serial PRIMARY KEY,
	chair_name varchar,
	dean varchar
);

INSERT INTO chair
VALUES (1, 'name', 'dean');

--no duplicates
INSERT INTO chair
VALUES (1, 'name', 'dean');

--no NULLs
INSERT INTO chair
VALUES (NULL, 'name', 'dean');

--only UNIQUE NOT NULLs
INSERT INTO chair
VALUES (2, 'name', 'dean');

--equivalent (almost) to:
DROP TABLE chair;
CREATE TABLE chair
(
	cathedra_id serial UNIQUE NOT NULL,
	chair_name varchar,
	dean varchar
);
ALTER TABLE chair
DROP CONSTRAINT chair_cathedra_id_key

select constraint_name
from information_schema.key_column_usage
where table_name = 'chair'
  and table_schema = 'public'
  and column_name = 'cathedra_id';
  
ALTER TABLE chair
ADD PRIMARY KEY(chair_id);

3. Внешний ключ в SQL (FOREIGN KEY)
CREATE TABLE public.publisher
(
    publisher_id integer NOT NULL,
    publisher_name varchar(128) NOT NULL,
    address text NOT NULL,
    
	CONSTRAINT PK_publisher_id PRIMARY KEY(publisher_id)
);

CREATE TABLE public.book
(
    book_id integer NOT NULL,
    title text NOT NULL,
    isbn character varying(32) NOT NULL,
    publisher_id integer NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);


--добавим немного данных в publisher
INSERT INTO publisher 
VALUES 
(1, 'Everyman''s Library', 'NY'),
(2, 'Oxford University Press', 'NY'),
(3, 'Grand Central Publishing', 'Washington'),
(4, 'Simon & Schuster', 'Chicago');

--без FK мы можем пихать любые значения
INSERT INTO book
VALUES 
(1, 'The Diary of a Young Girl', '0199535566', 10); -- Everyman's Library

SELECT *
FROM book;

TRUNCATE TABLE book;

ALTER TABLE book
ADD CONSTRAINT fk_books_publisher FOREIGN KEY(publisher_id) REFERENCES publisher(publisher_id);

-- теперь всякую дичь на вставить
insert into book
values 
(1, 'The Diary of a Young Girl', '0199535566', 10);

--если хотим сразу задать ограничение при создании таблицы
DROP TABLE book;

CREATE TABLE public.book
(
    book_id integer NOT NULL,
    title text NOT NULL,
    isbn character varying(32) NOT NULL,
    publisher_id integer NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id),
	CONSTRAINT FK_book_publisher FOREIGN KEY (publisher_id) REFERENCES publisher(publisher_id)
);

--если хотим удалить ограничение
ALTER TABLE book
DROP CONSTRAINT FK_book_publisher;

4. CHECK.sql
DROP TABLE IF EXISTS book;

CREATE TABLE public.book
(
    book_id integer NOT NULL,
    title text NOT NULL,
    isbn character varying(32) NOT NULL,
    publisher_id integer NOT NULL,
	  
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

ALTER TABLE book
ADD COLUMN price decimal CONSTRAINT CHK_book_price CHECK (price > 0);

INSERT INTO book
VALUES
(1, 'title', 'isbn', 1, -1.5);

5. DEFAULT.sql
CREATE TABLE customer
(
	customer_id serial,
	full_name text,	
	status char DEFAULT 'r',
	
	CONSTRAINT PK_customer_id PRIMARY KEY(customer_id),
	CONSTRAINT CHK_customer_status CHECK (status = 'r' or status = 'p')
);

INSERT INTO customer
VALUES
(1, 'name');

SELECT *
FROM customer;

INSERT INTO customer
VALUES
(1, 'name', 'd');

ALTER TABLE customer
ALTER COLUMN status DROP DEFAULT;

ALTER TABLE customer
ALTER COLUMN status SET DEFAULT 'r';

6. CREATE SEQUENCE
CREATE SEQUENCE seq;

SELECT nextval('seq');
SELECT currval('seq');
SELECT lastval();

--
SELECT setval('seq', 10);
SELECT currval('seq');
SELECT nextval('seq');

SELECT setval('seq', 16, false);
SELECT currval('seq');
SELECT nextval('seq');

--
CREATE SEQUENCE IF NOT EXISTS seq2 INCREMENT 16;
SELECT nextval('seq2');

--
CREATE SEQUENCE IF NOT EXISTS seq3
INCREMENT 16
MINVALUE 0
MAXVALUE 128
START WITH 0

SELECT nextval('seq3');

ALTER SEQUENCE seq3 RENAME TO seq4
ALTER SEQUENCE seq4 RESTART WITH 16
SELECT nextval('seq4');

DROP SEQUENCE seq4;

7. SERIAL
DROP TABLE IF EXISTS book;

CREATE TABLE public.book
(
    book_id int NOT NULL,
    title text NOT NULL,
    isbn varchar(32) NOT NULL,
    publisher_id int NOT NULL,
	  
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

CREATE SEQUENCE IF NOT EXISTS book_book_id_seq
START WITH 1 OWNED BY book.book_id;

-- doesn't work
INSERT INTO book (title, isbn, publisher_id)
VALUES ('title', 'isbn', 1);

--we need to set default
ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('book_book_id_seq');

--now should work
INSERT INTO book (title, isbn, publisher_id)
VALUES ('title', 'isbn', 1);

SELECT * 
FROM book;

INSERT INTO book (title, isbn, publisher_id)
VALUES ('title2', 'isbn2', 1);

SELECT * 
FROM book;

--BTW, we need the list of columns if we skip some of them inserting values
--so the following doesn't work
INSERT INTO book
VALUES ('title2', 'isbn2', 1);

--returning
INSERT INTO book (title, isbn, publisher_id)
VALUES ('title3', 'isbn3', 1)
RETURNING book_id;

8. INSERT
INSERT INTO author
VALUES (10, 'John Silver', 4.5);

SELECT * FROM author;

INSERT INTO author(author_id, full_name)
VALUES
(12, 'Name 1'),
(13, 'Name 2'),
(14, 'Name 3');

SELECT *
INTO best_authors
FROM author
WHERE rating > 4.5;

SELECT * FROM best_authors;

9. UPDATE, DELETE, RETURNING
SELECT * FROM author;

UPDATE author
SET full_name = 'Elias', rating = 5
WHERE author_id = 1;

DELETE FROM author
WHERE rating < 4.5;

DELETE FROM author;

TRUNCATE TABLE author;

DROP TABLE book;

CREATE TABLE book
(
	book_id serial,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	publisher_id int NOT NULL,
	
	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
);

INSERT INTO book(title, isbn, publisher_id)
VALUES ('title', 'isbn', 3)
RETURNING *;

UPDATE author
SET full_name = 'Walter', rating = 5
WHERE author_id = 1
RETURNING author_id;

DELETE FROM author
WHERE rating = 5
RETURNING *;

План конспекта:
    • Управляем таблицами: создание, изменение, удаление
    • Как создать первичный ключ в SQL (PRIMARY KEY)
    • Как создать внешний ключ в SQL (FOREIGN KEY)
    • Ограничение CHECK
    • DEFAULT - значения по умолчанию
    • Последовательности в PostgreSQL - CREATE SEQUENCE
    • Последовательности и таблицы - SERIAL
    • INSERT - Вставка данных в таблицу на SQL
    • UPDATE, DELETE, RETURNING - обновление и удаление данных из таблицы на SQL


    1. Управляем таблицами: создание, изменение, удаление
Создание, изменение и удаление таблиц
Операции по изменению таблиц имеют более стандартизированное название - DDL (Data Definition Language) и в данном уроке мы разберем все основные DDL операции, присутствующие в SQL.
Создание таблицы
Как мы ранее и говорили сама по себе БД является хранилищем данных. Но так как данные могут быть в абсолютно разных форматах и хранить разные сущности (заказы, товары, аккаунты), то каждую сущность хранят в отдельной таблице (Table).
Что такое таблица ? Самое простое представление это обычная таблица Excel или CSV, где у нас есть колонки, названия колонок и строки со значениями для этих колонок.
Для того, чтобы создать новую таблицу нам нужно воспользоваться командой CREATE TABLE. Ее синтаксис:
CREATE TABLE [IF NOT EXISTS] название_таблицы(
  название_колонки ТИП_КОЛОНКИ [ПАРАМЕТРЫ],
  название_другой_колонки ТИП_КОЛОНКИ [ПАРАМЕТРЫ]
);
Основные типы данных в SQL
В отличии от Ruby, в SQL каждая колонка имеет строгий тип определяемый при создании таблицы, а значит при попытке добавить туда значение неверного типа мы будем получать ошибку несоответсвия типов. Рассмотрим основные типы данных:
Числа
Числовые значения передаются без каких-либо дополнительных атрибутов.
INT - Натуральное число (например 100)
DOUBLE - число с плавающей запятой запятой (например 125.83)
Строки
Строковые значения при добавлении обрамляются одинарными ковычками (например 'John')
CHAR(макс_кол-во_символов) - строка с фиксированным максимальным размером. Если размер строки меньше указанного, то строка дополняется пробелами. Максимум символов - 8000
VARCHAR(макс_кол-во_символов) - строка с нефиксированным размером. Если размер меньше установленного, то размер не увеличивается и добавляется как есть.Максимум символов - 8000
TEXT - строка с максимальным размером значения в 2GB.
Метка времени
DATE - дата в формате YYYY-MM-DD. Значение передается с помощью обрамления в одинарные ковыки (например '2023-03-02')
TIME - время в формате HH:MI:SS. Значение передается с помощью обрамления в одинарные ковыки (например '00:00:00')
DATETIME - дата и время в формате YYYY-MM-DD HH:MI:SS. Значение передается с помощью обрамления в одинарные ковыки (например '2023-03-02 00:00:00')
TIMESTAMP - POSIX-время, количество секунд прошедшее с 00:00:00 UTC 1 января, 1970 года. Значение передается в цифровом формате без каких либо дополнительных атрибутов (например 1683107624)
Первичный ключ (PK)
Первичный ключ — особенное поле в SQL-таблице, которое позволяет однозначно идентифицировать каждую запись в ней. Первичный ключ всегда уникален. Благодаря нему БД может определять дубли. Например если вы добавили в таблицу сущность с ключом равным 3, то при попытке добавить еще одну сущнсть с таким же ключом, даже если все остальные поля отличаются, БД вернет нам ошибку и сущность добавлена не будет.
При этом сам первичный ключ может быть двух вариантов: односоставный и композитный.
Односоставный ключ
Односоставный ключ, судя по названию, является ключом таблицы состоящим из одной колонки. Создать односоставный ключ можно 2 способами:
Добавить PRIMARY KEY в качестве параметра у атрибута:
CREATE TABLE [IF NOT EXISTS] название_таблицы (
  название_колонки ТИП_ДАННЫХ PRIMARY KEY
);
Указать первичный ключ в качестве отдельного атрибута:
CREATE TABLE [IF NOT EXISTS] название_таблицы (
  название_колонки ТИП_ДАННЫХ,
  PRIMARY KEY (название_колонки)
);
Композитный ключ
Композитный ключ - ключ, состоящий из двух двух или более таблиц. Создается данный ключ в виде отдельного атрибута:
CREATE TABLE [IF NOT EXISTS] название_таблицы (
  название_колонки ТИП_ДАННЫХ,
  название_другой_колонки ТИП_ДАННЫХ
  PRIMARY KEY (название_колонки, название_другой_колонки)
);
Внешний ключ (FK)
Если первичный ключ является идентификатором нашей таблицы, то внешние ключи (Foreign Keys) предсталвяют из себя указатели на перевичный ключ другой таблицы. Отсюда и происходит название "реляционная". Когда мы объявляем внешний ключ, то мы всегда указываем на таблицу к которой он привязан, а также первичный ключ этой таблицы, к которому будет привязан наш внешний ключ.
Синтаксис внешнего ключа:
CREATE TABLE [IF NOT EXISTS] название_таблицы (
  название_колонки ТИП_ДАННЫХ,
  FOREIGN KEY (название_колонки) REFERENCES название_связанной_таблицы(название_колонки_связяанной_таблицы)
);
Ограничения
Помимо параметра первичного ключа, мы можем также указывать параметры, которые будут добавлять дополнительные проверки на стороне самой базы данных. Рассмотрим основные ограничения
NULL - параметр, обозначающий, что значение данного столбца может содержать в себе пустое значение NULL. По аналогии nil в Ruby.
Синтаксис:
CREATE TABLE название_таблицы (
  название_колонки ТИП_ДАННЫХ NULL
);
На самом деле NULL не является обязательным параметром. По-умолчанию, все колонки при создании могут содержать NULL.
NOT NULL - параметр, обозначающий, что значение данного столбца не может содержать в себе пустое значение NULL.
Синтаксис:
CREATE TABLE название_таблицы (
  название_колонки ТИП_ДАННЫХ NOT NULL
);
Если вы объявляете колонку NOT NULL, то, соответственно, вы переопределяете поведение по умолчанию. PRIMARY KEY по-умолчанию включает в себя параметр NOT NULL.
UNIQUE - параметр, обозначающий, что каждое значение в данной колонке - уникальное, т.е. если вы добавили значение 3, то другого такого же значения здесь быть не может.
Синтаксис:
CREATE TABLE название_таблицы (
  название_колонки ТИП_ДАННЫХ UNIQUE
);
PRIMARY KEY по-умолчанию включает в себя параметр UNIQUE.
AUTOINCREMENT - параметр, обозначающий, что каждое значение в данной колонке будет иметь на одну единицу больше, чем предыдущее добавленное. Например, вы добавили значение 3, при попытке добавить еще одно значение в эту же таблицу со значением для этой колонки NULL, оно будет равняться 4, а не NULL.
Синтаксис:
CREATE TABLE название_таблицы (
  название_колонки ТИП_ДАННЫХ AUTOINCREMENT
);
DEFAULT - параметр, обозначающий, что в случае передачи в качестве значения NULL, будет подставляться значение по-умолчанию, которое было заранее определено при создании таблицы.
Синтаксис:
CREATE TABLE название_таблицы (
  название_колонки ТИП_ДАННЫХ DEFAULT значение_по_умолчанию
);
Помимо статичного значения можно использовать динамичное, например current_timestamp, которое показывает каждый раз текущее время в формате POSIX.
Изменение таблицы
По ходу существования нашей таблицы в течении некоторого времени, у нас может появиться необходимость изменять схему путем добавления, удаления или переименования колонок. Для любого изменения таблицы используется команда ALTER TABLE и имеет синтаксис:
ALTER TABLE название_таблицы ПАРАМЕТР
Добавление колонок
Добавление колонки происходит с помощью добавления параметра ADD COLUMN.
Синтаксис:
ALTER TABLE название_таблицы ADD COLUMN название_добавляемой_колонки ТИП_КОЛОНКИ
Кроме того мы можем добавлять ограничения для новых колонок, например NOT NULL, UNIQUE или добавить значение по умолчанию.
Синтексис:
ALTER TABLE название_таблицы ADD COLUMN название_добавляемой_колонки ТИП_КОЛОНКИ ПАРАМЕТР
Удаление колонок
Синтаксис:
ALTER TABLE название_таблицы DROP COLUMN название_колонки
Переименнование колонок
Синтаксис:
ALTER TABLE название_таблицы RENAME COLUMN исходное_название_столбца TO итоговое_название_столбца
Удаление таблиц
Синтаксис:
DROP TABLE название_таблицы
Пример из реальной жизни
Давайте предположим, что мы занимаемся разработкой интернет-магазина. Преджде чем приступить к созданию базы данных, определимся какие сущности необходимы для нашего магазина:
Товары. Любой интернет магазин занимается продажей вещей, соответственно у любого интернет магазина есть товары.
Покупатели. Покупатель может зарегистрироваться на сайте, совершать покупки и тд.
Заказы. Заказы слушат некой связкой покупателя и товара. По заказу мы модем определить кто покупает и что покупает.
Товар
Какие атрибуты могут быть у товара ?
номер товара или его идентификатор. Значение, которое будет служить для отличия товаров друг от друга.
Производитель. Нам магазин может продать разные модели от одного и того же производителя
модель. Модель конкретного производителя
цвет. В магазине у нас может продаваться модель в разных цветах.
Дата добавления. Полезный атрибут, позволяющий отличить старый товар от нового.
цена
Соответсвенно мы можем все эти атрибуты превратить в таблицу:
id
manufacture
model
color
date_added
price
1
apple
iphone 14
black
01.12.2022
100000
2
samsung
a54
white
01.04.2023
30000
3
apple
iphone 14
white
21.12.2022
1010000
Как будет выглядеть создание такой таблицы:
CREATE TABLE IF NOT EXISTS items (
  id INTEGER PRIMARY KEY,
  manufacture TEXT NOT NULL,
  model TEXT NOT NULL,
  color TEXT NOT NULL,
  price INTEGER NOT NULL,
  date_added TIMESTAMP NOT NULL
);
Здесь мы указали, что нашим первичным ключом будет служить поле id, а все остальные атрибуты будут иметь параметр NOT NULL, что означает, что все поля обязательны для заполнения при добавлении нового товара.
Покупатели
Теперь подумаем какие атрибуты необходимы для покупателя:
идентификатор. Тоже самое, что и с товарами
имя. Часть персональных данных, необходимая для идентификации человека
фамилия. Другая часть персональных данных, необходимая для идентификации человека
телефон. Во время доставки нам важно иметь возможность иметь связь с покупателем для уточнения деталей.
email. Почта позволит оповещать нашего клиента о новом статусе заказа или рассылать рекламные предложения.
Итоговая таблица покупателей:
id
first_name
last_name
delivery_address
phone
email
1
Иван
Петров
Moscow, Lenina st, appt 12
79999999999
ivan.petrov@mail.ru
2
Ксения
Андреева
Vladimir, Aviation st, appt. 123, 23
79991111111
ksenya.andreeva@ya.ru
SQL синтаксис:
CREATE TABLE IF NOT EXISTS customers (
  id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  phone INTEGER NOT NULL UNIQUE,
  delivery_address TEXT NOT NULL,
  email TEXT
);
В данном случае у нас id снова служит первичным ключом, а все остальные поля обязательны, кроме email, что позволяет пользователю при регистрации его не вводить.
Заказы
Ну и наконец разберем атрибуты заказов:
идентификатор товара. Мы должны знать что покупает покупатель.
идентификатор покупателя. Мы должны знать кто покупает товар.
дата заказа. Благодаря дате мы сможем понимать является ли заказ одного и того же товара одним и тем же покупателем новым или старым заказом.
адрес доставки. Так как мы интернет магазин, то нам необходимо знать куда доставить заказ.
описание. Во время подтверждения заказа клиент модет дать нам дополнительную информацию, например время доставки и тд.
Итоговая таблица покупателей:
item_id
customer_id
date_added
description
1
2
2023-03-25 15:21:11
Доставка 2023.03.31 после 16:00
2
1
2023-02-12 10:32:16
Доставка 2023.02.13 после 08:00
1
2
2023-01-11 19:29:46
Доставка 2023.01.13 после 18:00
Синтаксис создания таблицы:
CREATE TABLE orders (
  item_id INTEGER NOT NULL,
  customer_id INTEGER NOT NULL,
  date_added TIMESTAMP NOT NULL,
  description TEXT,
  PRIMARY KEY (item_id, customer_id, date_created),
  FOREIGN KEY (item_id)  REFERENCES items(id),
  FOREIGN KEY (customer_id)  REFERENCES customers(id)
);
В данном случае нашим первичным ключом является композитный ключ состоящий из 3 колонок: item_id, customer_id и date_created. Так как:
Допустим мы бы сделали односоставный ключ с идентификатором товара или пользователя, тогда мы сталкиваемся с проблемой, что у нас либо может быть куплен только один товар, либо пользователь может совершить только одну покупку.
Если бы мы сделали композитный ключ состоящий из идентификатора пользователя и товара только, тогда бы пользователь не смог купить один и тот же товар более 1 раза.
Помимо первичного ключа у нас также присуствуют внешние ключи из которых:
item_id является значением столбца id из таблицы items.
customer_id является значением столбца id из таблицы customers.
Таким образом у нас не может появиться заказ с товаром, которого не существует или от пользователя, который не зарегистрировался.
Задание university
В конце урока будет приложена ER диаграмма базы данных university. Вам необходимо:
Написать для каждой таблицы отдельный файл в формате .sql с командой для создания этой таблицы. Файл должен называться create_название_таблицы_table.sql.
Запустить все эти скрипты для проверки работоспособности.
Рекомендации:
Будьте внимательны с очередностью выполнения .sql скриптов, так как часть таблиц зависят от других таблиц, то зависимые таблицы должны быть созданы вначале.



    2. Как создать первичный ключ в SQL (PRIMARY KEY)

Для создания двух первичных ключей в MS SQL использовать можно составной первичный ключ или альтернативное решение с использованием уникальных индексов. Примеры:

-- Пример с использованием составного первичного ключа
CREATE TABLE ExampleTable (
    ID1 INT,
    ID2 INT,
    CONSTRAINT PK_ExampleTable PRIMARY KEY (ID1, ID2)
);

-- Пример с использованием уникальных индексов
CREATE TABLE ExampleTable (
    ID1 INT,    ID2 INT,
    CONSTRAINT PK_ExampleTable PRIMARY KEY (ID1),
    CONSTRAINT UQ_ExampleTable UNIQUE (ID2)
);

COPY
В первом примере используется составной первичный ключ, который состоит из двух столбцов - ID1 и ID2. Второй пример демонстрирует использование двух отдельных ключей: первичного ключа на столбце ID1 и уникального индекса на столбце ID2.
Оба решения позволяют создать два первичных ключа в MS SQL.
Детальный ответ
Как сделать 2 первичных ключа в MS SQL?
Любая база данных должна иметь способ однозначной идентификации каждой строки в таблице. Для этого в SQL существует концепция первичного ключа, который уникально идентифицирует записи в таблице. В некоторых случаях возникает необходимость использования нескольких первичных ключей в одной таблице. В этой статье мы рассмотрим, как создать 2 первичных ключа в MS SQL.
1. Создание первичного ключа:
Для создания первичного ключа в SQL мы используем команду PRIMARY KEY. В примере ниже мы создадим таблицу "Users" с первичным ключом "id".

CREATE TABLE Users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);
COPY
В данном примере мы использовали поле "id" как первичный ключ. Он будет автоматически уникальным и не может содержать дубликатов значений.
2. Создание второго первичного ключа:
Чтобы создать вторичный первичный ключ, мы должны использовать понятие составного ключа (composite key) - ключ, состоящий из нескольких полей. Вот пример того, как создать таблицу "Orders" с двумя первичными ключами "order_id" и "user_id":

CREATE TABLE Orders (
    order_id INT,
    user_id INT,
    order_date DATE,
    PRIMARY KEY (order_id, user_id)
);
COPY
В этом примере мы использовали ключевое слово PRIMARY KEY, за которым следует список полей, образующих составной ключ. В данном случае, "order_id" и "user_id" являются первичными ключами таблицы "Orders".
Важно отметить, что при использовании составного ключа, значения каждого поля в комбинации должны быть уникальными в пределах таблицы. Одинаковые комбинации значений не могут существовать.
3. Работа с таблицей, имеющей два первичных ключа:
После создания таблицы с двумя первичными ключами, мы можем выполнять различные операции, такие как вставка, обновление и удаление записей.
Вставка записи, содержащей два первичных ключа:

INSERT INTO Orders (order_id, user_id, order_date)
VALUES (1, 100, '2021-01-01');
COPY
Обновление записи, содержащей два первичных ключа:

UPDATE Orders
SET order_date = '2021-01-02'
WHERE order_id = 1 AND user_id = 100;
COPY
Удаление записи, содержащей два первичных ключа:

DELETE FROM Orders
WHERE order_id = 1 AND user_id = 100;
COPY
Это основные операции, которые можно выполнять с таблицей, имеющей два первичных ключа.
Заключение:
В этой статье мы рассмотрели, как создать 2 первичных ключа в MS SQL. Мы узнали, что первичный ключ используется для идентификации уникальных записей в таблице, а составной ключ позволяет использовать несколько полей в качестве первичных ключей. При работе с таблицей, содержащей два первичных ключа, мы можем выполнять различные операции: вставка, обновление и удаление записей.

3.Как создать внешний ключ в SQL (FOREIGN KEY)
Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.
Общий синтаксис установки внешнего ключа на уровне таблицы:
1
2
3
4
5
[CONSTRAINT имя_ограничения]
FOREIGN KEY (столбец1, столбец2, ... столбецN) 
REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
[ON DELETE действие]
[ON UPDATE действие]
Для создания ограничения внешнего ключа после FOREIGN KEY указывается столбец таблицы, который будет представляет внешний ключ. А после ключевого слова REFERENCES указывается имя связанной таблицы, а затем в скобках имя связанного столбца, на который будет указывать внешний ключ. После выражения REFERENCES идут выражения ON DELETE и ON UPDATE, которые задают действие при удалении и обновлении строки из главной таблицы соответственно.
Например, определим две таблицы и свяжем их посредством внешнего ключа:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT, 
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
 
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);
В данном случае определены таблицы Customers и Orders. Customers является главной и представляет клиента. Orders является зависимой и представляет заказ, сделанный клиентом. Таблица Orders через столбец CustomerId связана с таблицей Customers и ее столбцом Id. То есть столбец CustomerId является внешним ключом, который указывает на столбец Id из таблицы Customers.
С помощью оператора CONSTRAINT можно задать имя для ограничения внешнего ключа:
1
2
3
4
5
6
7
8
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    CONSTRAINT orders_custonmers_fk 
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);
ON DELETE и ON UPDATE
С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:
    • CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.
    • SET NULL: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)
    • RESTRICT: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.
    • NO ACTION: то же самое, что и RESTRICT.
    • SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Несмотря на то, что данная опция в принципе доступна, однако движок InnoDB не поддерживает данное выражение.
Каскадное удаление
Каскадное удаление позволяет при удалении строки из главной таблицы автоматически удалить все связанные строки из зависимой таблицы. Для этого применяется опция CASCADE:
1
2
3
4
5
6
7
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);
Подобным образом работает и выражение ON UPDATE CASCADE. При изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. Однако поскольку первичные ключи изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.
Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:
1
2
3
4
5
6
7
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);
Если таблица уже была ранее создана, и ее необходимо изменить, то для этого применяется команда ALTER TABLE. Ее сокращенный формальный синтаксис:
1
2
3
4
5
6
7
ALTER TABLE название_таблицы 
{ ADD название_столбца тип_данных_столбца [атрибуты_столбца] | 
  DROP COLUMN название_столбца |
  MODIFY COLUMN название_столбца тип_данных_столбца [атрибуты_столбца] |
  ALTER COLUMN название_столбца SET DEFAULT значение_по_умолчанию |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
Вообще данная команда поддерживает гораздо больше опций и возможностей. Все их можно посмотреть в документации. Рассмотрим лишь основные сценарии, с которыми мы можем столкнуться.
Добавление нового столбца
Добавим в таблицу Customers новый столбец Address:
1
2
ALTER TABLE Customers
ADD Address VARCHAR(50) NULL;
В данном случае столбец Address имеет тип VARCHAR и для него определен атрибут NULL.
Удаление столбца
Удалим столбец Address из таблицы Customers:
1
2
ALTER TABLE Customers
DROP COLUMN Address;
Изменение значения по умолчанию
Установим в таблице Customers для столбца Age значение по умолчанию 22:
1
2
ALTER TABLE Customers
ALTER COLUMN Age SET DEFAULT 22;
Изменение типа столбца
Изменим в таблице Customers тип данных у столбца FirstName на CHAR(100) и установим для него атрибут NULL:
1
2
ALTER TABLE Customers
MODIFY COLUMN FirstName CHAR(100) NULL;
Добавление и удаление внешнего ключа
Пусть изначально в базе данных будут добавлены две таблицы, никак не связанные:
1
2
3
4
5
6
7
8
9
10
11
12
13
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT, 
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL
);
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date
);
Добавим ограничение внешнего ключа к столбцу CustomerId таблицы Orders:
1
2
ALTER TABLE Orders
ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
При добавлении ограничений мы можем указать для них имя, используя оператор CONSTRAINT, после которого указывается имя ограничения:
1
2
3
ALTER TABLE Orders
ADD CONSTRAINT orders_customers_fk 
FOREIGN KEY(CustomerId) REFERENCES Customers(Id);
В данном случае ограничение внешнего ключа называется orders_customers_fk. Затем по этому имени мы можем удалить ограничение:
1
2
ALTER TABLE Orders
DROP FOREIGN KEY orders_customers_fk;
Добавление и удаление первичного ключа
Добавим в таблицу Products первичный ключ:
1
2
3
4
5
6
7
8
CREATE TABLE Products
(
    Id INT,
    Model VARCHAR(20)
);
 
ALTER TABLE Products
ADD PRIMARY KEY (Id);
Теперь удалим первичный ключ:
1
2
ALTER TABLE Products
DROP PRIMARY KEY;


4. Ограничение CHECK
Ключевое слово CHECK задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после слова CHECK указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100:
1
2
3
4
5
6
7
8
9
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30) UNIQUE CHECK(Email !=''),
    Phone VARCHAR(20) UNIQUE CHECK(Phone !='')
);
Здесь также указывается, что столбцы Email и Phone не могут иметь пустую строку в качестве значения (пустая строка не эквивалентна значению NULL).
Для соединения условий используется ключевое слово AND. Условия можно задать в виде операций сравнения больше (>), меньше (<), не равно (!=).
Также с помощью CHECK можно создать ограничение в целом для таблицы:
1
2
3
4
5
6
7
8
9
10
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18,
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30) UNIQUE,
    Phone VARCHAR(20) UNIQUE,
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
)


5. DEFAULT - значения по умолчанию
Атрибут DEFAULT определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.
1
2
3
4
5
6
7
8
9
CREATE TABLE Customers
(
    Id INT PRIMARY KEY IDENTITY,
    Age INT DEFAULT 18,
    FirstName NVARCHAR(20) NOT NULL,
    LastName NVARCHAR(20) NOT NULL,
    Email VARCHAR(30) UNIQUE,
    Phone VARCHAR(20) UNIQUE
);
Здесь для столбца Age предусмотрено значение по умолчанию 18.









6. Последовательности в PostgreSQL - CREATE SEQUENCE
Последовательность в PostgreSQL - это определяемый пользователем объект с привязкой к схеме, который выдает последовательность целых чисел на основе указанной спецификации. Оператор CREATE SEQUENCE используется для создания последовательностей в PostgreSQL.

Теперь давайте проанализируем приведенный выше синтаксис:

Сначала задайте имя последовательности после предложения CREATE SEQUENCE . Команда IF NOT EXISTS условно создает новую последовательность, только если она не существует.
Во-вторых, укажите тип данных последовательности. Допустимые типы данных - SMALLINT, INT и BIGINT. Тип данных по умолчанию - BIGINT, если вы его пропустите. Используется для определения минимального и максимального значений последовательности.
Приращение указывает, какое значение следует добавить к текущему значению последовательности, чтобы создать новое значение. Положительное число образует последовательность по возрастанию, в то время как отрицательное число образует последовательность по убыванию. Значение приращения по умолчанию равно 1.
Затем мы определяем минимальное и максимальное значение последовательности. Если вы не используете МИНИМАЛЬНОЕ или МАКСИМАЛЬНОЕ значение, последовательность будет использовать значение по умолчанию. Для восходящей последовательности максимальное значение по умолчанию - это максимальное значение типа данных последовательности, а минимальное значение по умолчанию равно 1, тогда как в случае нисходящей последовательности максимальное значение по умолчанию равно -1, а минимальное значение по умолчанию - это минимальное значение типа данных последовательности.
Предложение START указывает начальное значение последовательности.
ЦИКЛ позволяет перезапустить значение, если достигнут предел. Следующим числом будет минимальное значение для возрастающей последовательности и максимальное значение для убывающей последовательности. Если вы используете NO CYCLE, то при достижении предела попытка получить следующее значение приведет к ошибке. Значение NO CYCLE используется по умолчанию, если вы явно не указали CYCLE или ОТСУТСТВИЕ ЦИКЛА.
Предложение OWNED BY позволяет вам связать столбец таблицы с последовательностью, так что при удалении столбца или таблицы PostgreSQL автоматически удалит связанную последовательность.
Теперь давайте перейдем к некоторым примерам.

Пример 1:
В этом примере мы будем использовать инструкцию CREATE SEQUENCE для создания новой возрастающей последовательности, начинающейся с 10, с шагом 5:
CREATE SEQUENCE mysequence
INCREMENT 5
START 10;
Чтобы получить следующее значение из последовательности, используйте функцию nextval():
SELECT nextval('mysequence');







Это приведет к следующему результату:

Теперь, если мы повторим функцию nexval(), мы получим увеличенное значение.

Вывод:




7. Последовательности и таблицы – SERIAL
Слово "serial" в SQL означает автоинкрементное поле или столбец, которое автоматически увеличивается на один с каждой новой записью.
Вот пример использования "serial" в базе данных PostgreSQL:

CREATE TABLE students (
    id serial PRIMARY KEY,
    name varchar(50),
    age integer
);
COPY
В примере выше, столбец "id" имеет тип данных "serial", что означает, что каждая новая запись будет автоматически получать уникальное значение "id" с автоинкрементом. 
Реклама
Детальный ответ
Привет, студент! Сегодня мы поговорим о том, что означает "serial SQL" в контексте баз данных.
Serial SQL - это специфический тип данных, который используется в базах данных для автоматической генерации уникальных и последовательных значений.
Итак, давайте разберемся подробнее, что это значит и как это работает.
Что такое "serial SQL"?
"Serial SQL" - это название типа данных в языке PostgreSQL, который представляет собой автоматически генерируемый уникальный целочисленный идентификатор. В других базах данных этот тип может иметь разные названия, например, "auto-increment" в MySQL или "identity" в Microsoft SQL Server.
Особенность "serial SQL" заключается в том, что каждый новый добавленный элемент в базу данных будет автоматически получать следующее по порядку значение этого типа данных. Это позволяет удобно идентифицировать каждую запись в таблице с помощью уникального и последовательного идентификатора.
Пример использования "serial SQL"
Давайте рассмотрим пример, чтобы понять, как использовать "serial SQL". Предположим, у нас есть таблица "users" в базе данных, и мы хотим добавить новую запись в эту таблицу:
        
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(50)
);
        
    
COPY
В приведенном выше примере мы создали таблицу "users" с полем "id" типа "SERIAL PRIMARY KEY". Это означает, что поле "id" будет автоматически генерироваться базой данных и использоваться в качестве уникального идентификатора для каждой записи в таблице.
Теперь, чтобы добавить новую запись в таблицу "users", нам нужно указать только поля "name" и "email", а поле "id" будет автоматически заполнено базой данных:
        
INSERT INTO users (name, email)
VALUES ('John Doe', 'johndoe@example.com');
        
    
COPY
После выполнения этого запроса база данных автоматически сгенерирует и вставит следующее по порядку значение "id" в таблицу "users".
Получение значения "serial SQL"
Если вы хотите получить значение, которое будет автоматически сгенерировано базой данных при добавлении новой записи, вы можете использовать ключевое слово "RETURNING" с командой "INSERT". Например:
        
INSERT INTO users (name, email)
VALUES ('Jane Smith', 'janesmith@example.com')
RETURNING id;
        
    
COPY
В этом случае база данных вернет значение "id", сгенерированное для новой записи.

8. INSERT - Вставка данных в таблицу на SQL
Оператор INSERT вставляет новые записи в таблицу. При этом значения столбцов могут представлять собой литеральные константы, либо являться результатом выполнения подзапроса. В первом случае для вставки каждой строки используется отдельный оператор INSERT; во втором случае будет вставлено столько строк, сколько возвращается подзапросом.
Синтаксис оператора следующий:
    1. INSERT INTO <имя таблицы>[(<имя столбца>,...)]
    2. {VALUES (<значение столбца>,…)}
    3. | <выражение запроса> 
    4. | {DEFAULT VALUES}
Как видно из представленного синтаксиса, список столбцов не является обязательным (об этом говорят квадратные скобки в описании синтаксиса). В том случае, если он отсутствует, список вставляемых значений должен быть полный, то есть обеспечивать значения для всех столбцов таблицы. При этом порядок значений должен соответствовать порядку, заданному оператором CREATE TABLE для таблицы, в которую вставляются строки. Кроме того, эти значения должны относиться к тому же типу данных, что и столбцы, в которые они вносятся. В качестве примера рассмотрим вставку строки в таблицу Product, созданную следующим оператором CREATE TABLE:
    1. CREATE TABLE product 
    2. (
    3.  maker char (1) NOT NULL,
    4.  model varchar (4) NOT NULL,
    5.  type varchar (7) NOT NULL 
    6. );
Пусть требуется добавить в эту таблицу модель ПК 1157 производителя B. Это можно сделать следующим оператором:
    1. INSERT INTO Product 
    2. VALUES ('B', 1157, 'PC');
Если задать список столбцов, то можно изменить «естественный» порядок их следования:
    1. INSERT INTO Product (type, model, maker) 
    2. VALUES ('PC', 1157, 'B');
Казалось бы, это совершенно излишняя возможность, которая делает конструкцию только более громоздкой. Однако она становится выигрышной, если столбцы имеют значения по умолчанию. Рассмотрим следующую структуру таблицы:
    1. CREATE TABLE product_D 
    2. (
    3.  maker char (1) NULL,
    4.  model varchar (4) NULL,
    5.  type varchar (7) NOT NULL DEFAULT 'PC'
    6. );
Отметим, что здесь значения всех столбцов имеют значения по умолчанию (первые два — NULL, а последний столбец — type — PC). Теперь мы могли бы написать:
    1. INSERT INTO Product_D (model, maker) 
    2. VALUES (1157, 'B');
В этом случае отсутствующее значение при вставке строки будет заменено значением по умолчанию — PC. Заметим, что если для столбца в операторе CREATE TABLE не указано значение по умолчанию и не указано ограничение NOT NULL, запрещающее использование NULL в данном столбце таблицы, то подразумевается значение по умолчанию NULL.
Возникает вопрос: а можно ли не указывать список столбцов и, тем не менее, воспользоваться значениями по умолчанию? Ответ положительный. Для этого нужно вместо явного указания значения использовать зарезервированное слово DEFAULT:
    1. INSERT INTO Product_D 
    2. VALUES ('B', 1158, DEFAULT);
Поскольку все столбцы имеют значения по умолчанию, для вставки строки со значениями по умолчанию можно было бы написать:
    1. INSERT INTO Product_D 
    2. VALUES (DEFAULT, DEFAULT, DEFAULT);
Однако для этого случая предназначена специальная конструкция DEFAULT VALUES (см. синтаксис оператора), с помощью которой вышеприведенный оператор можно переписать в виде
    1. INSERT INTO Product_D DEFAULT VALUES;
Заметим, что при вставке строки в таблицу проверяются все ограничения, наложенные на данную таблицу. Это могут быть ограничения первичного ключа или уникального индекса, проверочные ограничения типа CHECK, ограничения ссылочной целостности. В случае нарушения какого-либо ограничения вставка строки будет отклонена. Рассмотрим теперь случай использования подзапроса. Пусть нам требуется вставить в таблицу Product_D все строки из таблицы Product, относящиеся к моделям персональных компьютеров (type = ‘PC’). Поскольку необходимые нам значения уже имеются в некоторой таблице, то формирование вставляемых строк вручную, во-первых, является неэффективным, а, во-вторых, может допускать ошибки ввода. Использование подзапроса решает эти проблемы:
    1. INSERT INTO Product_D 
    2. SELECT * 
    3. FROM Product 
    4. WHERE type = 'PC';
Использование в подзапросе символа «*» является в данном случае оправданным, так как порядок следования столбцов является одинаковым для обеих таблиц. Если бы это было не так, следовало бы применить список столбцов либо в операторе INSERT, либо в подзапросе, либо в обоих местах, который приводил бы в соответствие порядок следования столбцов:
    1. INSERT INTO Product_D(maker, model, type) 
    2. SELECT * 
    3. FROM Product 
    4. WHERE type = 'PC';
или
    1. INSERT INTO Product_D 
    2. SELECT maker, model, type 
    3. FROM Product 
    4. WHERE type = 'PC';
или
    1. INSERT INTO Product_D(maker, model, type) 
    2. SELECT maker, model, type 
    3. FROM Product 
    4. WHERE type = 'PC';
Здесь, также как и ранее, можно указывать не все столбцы, если требуется использовать имеющиеся значения по умолчанию, например:
    1. INSERT INTO Product_D (maker, model) 
    2. SELECT maker, model 
    3. FROM Product 
    4. WHERE type = 'PC';
В данном случае в столбец type таблицы Product_D будет подставлено значение по умолчанию PC для всех вставляемых строк.
Отметим, что при использовании подзапроса, содержащего предикат, будут вставлены только те строки, для которых значение предиката равно TRUE (не UNKNOWN!). Другими словами, если бы столбец type в таблице Product допускал бы NULL-значение, и это значение присутствовало бы в ряде строк, то эти строки не были бы вставлены в таблицу Product_D.
Преодолеть ограничение на вставку одной строки в операторе INSERT при использовании конструктора строки в предложении VALUES позволяет искусственный прием использования подзапроса, формирующего строку с предложением UNION ALL. Так если нам требуется вставить несколько строк при помощи одного оператора INSERT, можно написать:
    1. INSERT INTO Product_D 
    2. SELECT 'B' AS maker, 1158 AS model, 'PC' AS type
    3. UNION ALL
    4. SELECT 'C', 2190, 'Laptop'
    5. UNION ALL
    6. SELECT 'D', 3219, 'Printer';
Использование UNION ALL предпочтительней UNION даже, если гарантировано отсутствие строк-дубликатов, так как в этом случае не будет выполняться проверка для исключения дубликатов.
Следует отметить, что вставка нескольких кортежей с помощью конструктора строк уже реализована в SQL Server 2008. С учетом этой возможности, последний запрос можно переписать в виде:
    1. INSERT INTO Product_D VALUES
    2. ('B', 1158, 'PC'),
    3. ('C', 2190, 'Laptop'),
    4. ('D', 3219, 'Printer');


Заметим, что MySQL допускает еще одну нестандартную синтаксическую конструкцию, выполняющую вставку строки в таблицу в стиле оператора UPDATE:
    1. INSERT [INTO] <имя таблицы>
    2.   SET {<имя столбца>={<выражение> | DEFAULT}}, ...


Рассмотренный в начале параграфа пример с помощью этого оператора можно переписать так:
    1. INSERT INTO Product
    2. SET maker = 'B',
    3.        model = 1157,
    4.        type = 'PC';

9. UPDATE, DELETE, RETURNING - обновление и удаление данных из таблицы на SQL
До этого мы рассмотрели Insert, чтобы добавить данные в нашу базу данных, и потратили много времени на Select, который обрабатывает широкий спектр использования для извлечения данных из базы данных. В этом разделе мы рассмотрим конструкции Update и Delete, которые используются для изменения существующих строк и удаления существующих строк. В этом разделе мы рассмотрим эти конструкции с точки зрения Core.
ORM-читатели - Как и в случае, упомянутом в Использование операторов INSERT, операции Update и Delete, когда они используются с ORM, обычно вызываются внутренне из объекта Session в рамках процесса единицы работы.
Однако, в отличие от Insert, конструкции Update и Delete также могут использоваться напрямую с ORM, используя шаблон, известный как «ORM-enabled update and delete»; поэтому знакомство с этими конструкциями полезно для использования ORM. Оба стиля использования обсуждаются в разделах Обновление объектов ORM с использованием шаблона единицы работы и Удаление объектов ORM с использованием шаблона единицы работы.
Конструкция выражения SQL update()
Функция update() генерирует новый экземпляр Update, который представляет оператор UPDATE в SQL, который обновит существующие данные в таблице.
Как и конструкция insert(), есть «традиционная» форма update(), которая генерирует оператор UPDATE для одной таблицы за раз и не возвращает никаких строк. Однако некоторые бэкэнды поддерживают оператор UPDATE, который может изменятьМетод Update.values() управляет содержимым элементов SET оператора UPDATE. Этот метод используется также в конструкции Insert. Обычно параметры могут быть переданы с использованием имен столбцов в качестве именованных аргументов.
UPDATE поддерживает все основные формы SQL UPDATE, включая обновления по выражениям, где мы можем использовать выражения Column:
>>> stmt = update(user_table).values(fullname="Username: " + user_table.c.name)
>>> print(stmt)
UPDATE user_account SET fullname=(:name_1 || user_account.name)
Для поддержки UPDATE в контексте "executemany", где множество наборов параметров будут вызываться для одного и того же оператора, можно использовать конструкцию bindparam() для настройки привязанных параметров; они заменяют места, где обычно находятся литеральные значения:
>>> from sqlalchemy import bindparam
>>> stmt = (
...     update(user_table)
...     .where(user_table.c.name == bindparam("oldname"))
...     .values(name=bindparam("newname"))
... )
>>> with engine.begin() as conn:
...     conn.execute(
...         stmt,
...         [
...             {"oldname": "jack", "newname": "ed"},
...             {"oldname": "wendy", "newname": "mary"},
...             {"oldname": "jim", "newname": "jake"},
...         ],
...     )
BEGIN (implicit)
UPDATE user_account SET name=? WHERE user_account.name = ?
[...] [('ed', 'jack'), ('mary', 'wendy'), ('jake', 'jim')]
<sqlalchemy.engine.cursor.CursorResult object at 0x...>
COMMIT
Другие техники, которые могут быть применены к UPDATE, включают:
Связанные обновления
Оператор UPDATE может использовать строки в других таблицах, используя связанный подзапрос. Подзапрос может быть использован в любом месте, где может быть размещено выражение столбца:
>>> scalar_subq = (
...     select(address_table.c.email_address)
...     .where(address_table.c.user_id == user_table.c.id)
...     .order_by(address_table.c.id)
...     .limit(1)
...     .scalar_subquery()
... )
>>> update_stmt = update(user_table).values(fullname=scalar_subq)
>>> print(update_stmt)
UPDATE user_account SET fullname=(SELECT address.email_address
FROM address
WHERE address.user_id = user_account.id ORDER BY address.id
LIMIT :param_1)
UPDATE..FROM
Некоторые базы данных, такие как PostgreSQL и MySQL, поддерживают синтаксис "UPDATE FROM", где дополнительные таблицы могут быть указаны непосредственно в специСуществует также специфический для MySQL синтаксис, который может обновлять несколько таблиц. Для этого необходимо ссылаться на объекты Table в клаузе VALUES, чтобы ссылаться на дополнительные таблицы:
>>> update_stmt = (
...     update(user_table)
...     .where(user_table.c.id == address_table.c.user_id)
...     .where(address_table.c.email_address == "patrick@aol.com")
...     .values(
...         {
...             user_table.c.fullname: "Pat",
...             address_table.c.email_address: "pat@aol.com",
...         }
...     )
... )
>>> from sqlalchemy.dialects import mysql
>>> print(update_stmt.compile(dialect=mysql.dialect()))
UPDATE user_account, address
SET address.email_address=%s, user_account.fullname=%s
WHERE user_account.id = address.user_id AND address.email_address = %s
Обновления с упорядоченными параметрами
Еще одно поведение, специфичное только для MySQL, заключается в том, что порядок параметров в клаузе SET в операторе UPDATE фактически влияет на вычисление каждого выражения. Для этого случая метод Update.ordered_values() принимает последовательность кортежей, чтобы этот порядок можно было контролировать [2]:
>>> update_stmt = update(some_table).ordered_values(
...     (some_table.c.y, 20), (some_table.c.x, some_table.c.y + 10)
... )
>>> print(update_stmt)
UPDATE some_table SET y=:y, x=(some_table.y + :y_1)
[2] Хотя словари Python гарантированно упорядочены по вставке, начиная с Python 3.7, метод Update.ordered_values() все еще обеспечивает дополнительную ясность намерений, когда необходимо, чтобы клауза SET оператора MySQL UPDATE происходила в определенном порядке.
Конструкция выражения SQL delete()
Функция delete() генерирует новый экземпляр Delete, который представляет оператор DELETE в SQL, который удаляет строки из таблицы.
Конструкция delete() с точки зрения API очень похожа на конструкцию update(), традиционно не возвращая строк, но позволяя использовать вариант RETURNING на некоторых базах данных.
>>> from sqlalchemy import delete
>>> stmt = delete(user_table).where(user_table.c.name == "patrick")
>>> print(stmt)
DELETE```
>>> delete_stmt = (
...     delete(user_table)
...     .where(user_table.c.id == address_table.c.user_id)
...     .where(address_table.c.email_address == "patrick@aol.com")
... )
>>> from sqlalchemy.dialects import mysql
>>> print(delete_stmt.compile(dialect=mysql.dialect()))
DELETE FROM user_account USING user_account, address
WHERE user_account.id = address.user_id AND address.email_address = %s
Получение количества затронутых строк при UPDATE, DELETE
Классы Update и Delete поддерживают возможность возвращения количества строк, соответствующих условию, после выполнения операции, для операций, которые вызываются через Connection ядра, т.е. Connection.execute(). С учетом оговорок, упомянутых ниже, это значение доступно через атрибут CursorResult.rowcount:
>>> with engine.begin() as conn:
...     result = conn.execute(
...         update(user_table)
...         .values(fullname="Patrick McStar")
...         .where(user_table.c.name == "patrick")
...     )
...     print(result.rowcount)
BEGIN (implicit)
UPDATE user_account SET fullname=? WHERE user_account.name = ?
[...] ('Patrick McStar', 'patrick')
1
COMMIT
Совет
Класс CursorResult является подклассом Result, который содержит дополнительные атрибуты, специфичные для объекта cursor DBAPI. Экземпляр этого подкласса возвращается, когда оператор вызывается через метод Connection.execute(). При использовании ORM метод Session.execute() возвращает объект этого типа для всех операторов INSERT, UPDATE и DELETE.
Факты об CursorResult.rowcount: Возвращаемое значение - это количество строк, соответствующих* условию WHERE в запросе. Не имеет значения, были ли строки фактически изменены или нет. * CursorResult.rowcount не всегда доступен для операторов UPDATE или DELETE, использующих RETURNING. * Для выполнения executemany CursorResult.rowcount также может быть недоступен, что сильно зависит от используемого модуля DBAPI и настроенных параметров. Атрибут CursorResult.supports_sane_multi_rowcount указывает, будет ли этот параметр доступен для текущей используемой базы данных. * Некоторые драйверы, особенно сторонние диалекты для нереляционных баз данных, могут вообще не поддерживать CursorResult.rowcount. Атрибут CursorResult.supports_sane_rowcount указывает на это. * «rowcount» используется процессом ORM unit of work для проверки того, что оператор UPDATE или DELETE соответствует ожидаемому количеству строк, и также является необходимым для функции ORM версионирования, описанной в разделе Configuring a Version Counter.
Использование RETURNING с UPDATE, DELETE
Как и конструкция Insert, Update и Delete также поддерживают оператор RETURNING, который добавляется с помощью методов Update.returning() и Delete.returning(). Когда эти методы используются на бэкэнде, который поддерживает RETURNING, выбранные столбцы из всех строк, которые соответствуют условиям WHERE в запросе, будут возвращены в объекте Result в виде строк, которые можно перебирать:
```
update_stmt = ( ... update(user_table) ... .where(user_table.c.name == "patrick") ... .values(fullname="Patrick the Star") ... .returning(user_table.c.id, user_table.c.name) ... ) print(update_stmt) UPDATE user_account SET fullname=:fullname WHEREORM-возможности для UPDATE и DELETE:
    • Update - обновление данных
    • Delete - удаление данных
